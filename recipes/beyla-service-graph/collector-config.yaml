# Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

apiVersion: opentelemetry.io/v1alpha1
kind: OpenTelemetryCollector
metadata:
  name: otel
spec:
  image: otel/opentelemetry-collector-contrib:0.90.0
  config: |
    receivers:
      # receive OTLP spans from Beyla
      otlp:
        protocols:
          grpc:
          http:
    connectors:
      # convert spans into an http.servicegraph.calls metric
      spanmetrics/httpservicegraph:
        histogram:
          disable: true
        dimensions:
          - name: http.request.method
            default: GET
          - name: http.response.status_code
          - name: server.address
          - name: http.route
          - name: client.address
          - name: k8s.pod.name
          - name: k8s.pod.uid
          - name: k8s.namespace.name
        exclude_dimensions: ['status.code', 'span.kind', 'span.name', 'service.name']
        namespace: http.servicegraph
    processors:
      # filter down to only non-local http server spans
      filter/httpserveronly:
        error_mode: ignore
        traces:
          span:
            - attributes["http.request.method"] == nil
            - kind.string != "Server"
            - attributes["server.address"] == "127.0.0.1"
      # detect gke resource attributes
      resourcedetection:
        detectors: [env, gcp]
        timeout: 2s
        override: false
      # Move server.address from a metric attribute to a resource attribute so we can use it to get k8s attributes.
      groupbyattrs:
        keys:
          - server.address
      # Assume server.address is a pod IP address
      resource:
        attributes:
          - key: k8s.pod.ip
            from_attribute: server.address
            action: insert
      transform/prometheusconventions:
        metric_statements:
          - context: datapoint
            statements:
              - set(attributes["code"], attributes["http.response.status_code"])
              - delete_key(attributes, "http.response.status_code")
              - set(attributes["method"], attributes["http.request.method"])
              - delete_key(attributes, "http.request.method")
              # GMP metrics are expected to be double
              - set(value_double, Double(value_int))
      resource/podinstance:
        attributes:
          - key: pod
            from_attribute: k8s.pod.name
            action: upsert
          - key: service.instance.id
            from_attribute: k8s.pod.uid
            action: upsert
    exporters:
      googlemanagedprometheus:
        metric:
          resource_filters:
            - regex: 'pod'
      googlecloud:
      logging:
        loglevel: debug
    service:
      pipelines:
        traces:
          receivers: [otlp]
          processors: [filter/httpserveronly]
          exporters: [spanmetrics/httpservicegraph]
        metrics:
          receivers: [spanmetrics/httpservicegraph]
          processors: [groupbyattrs, resource, resource/podinstance, transform/prometheusconventions, resourcedetection]
          exporters: [logging, googlemanagedprometheus]
